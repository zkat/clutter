;;;; Inference

;;; Entry level

(def-op! infer-code env (code decl)
  (let (ast (mark-ast code))
    (substitute-vars ast (unify (make-constraints ast (eval decl env))))))

;;; AST marking

(def! type-var? symbol?)

(def-fun! mark-ast (ast)
  (let (counter 0)
    (letrec (mark-ast-helper
             (lambda (ast)
               (let (current counter)
                 (set! counter (+ counter 1))
                 (cons (if (cons? ast)
                           (map mark-ast-helper ast)
                           ast)
                       (intern current)))))
      (mark-ast-helper ast))))

(def-fun! substitute-vars (ast constraints)
  (let* (form (car ast)
         var (cdr ast)
         subed-form (if (cons? form)
                        (map (rcurry substitute-vars constraints) form)
                        form))
    (let (subst (find-constraint var constraints))
      (if (false? subst)
          subed-form
          (cons subed-form (constraint-right subst))))))

;;; Constraints
(def-fun! make-constraint (left right)
  (list :constraint left right))

(def-fun! constraint? (c)
  (and? (sequence? c)
        (eql? (car c) :constraint)))

(def-fun! constraint-left (c)
  (second c))

(def-fun! constraint-right (c)
  (third c))

(def-fun! find-constraint (key list)
  (if (empty? list)
      #f
      (if (eql? key (constraint-left (car list)))
          (car list)
          (find-constraint key (cdr list)))))

;;; Constraint generation

(def-fun! make-constraints (form decl &rest declared-type)
  (let (actual-form (car form)
        tv (cdr form))
    (if (not (cons? actual-form))
        (make-atom-constraints actual-form decl tv)
        (if (not (cons? (car (car actual-form))))
            (let (comb (eval (car (car actual-form)) decl))
              (cond
                (#t (make-combiner-constraints actual-form decl tv))))
            (make-combiner-constraints actual-form decl tv)))))

(def-fun! make-atom-constraints (atom decl tv)
  (list
   (make-constraint tv
                    (if ((any-of number? boolean? keyword?) atom)
                        (make-enumeration-type atom)
                        (eval atom decl)))))

(def-fun! make-combiner-constraints (form decl tv)
  (destructuring-bind (comb &rest args) form
    (let* (comb-constraints (make-constraints comb decl)
           comb-type (constraint-right (find-constraint (cdr comb) comb-constraints)))
      (append
       (list
        (make-constraint tv (arrow-type-return-type comb-type))
        (make-constraint (cdr comb) comb-type)
        (make-constraint (make-function-type (apply make-prod-type (map cdr args)) tv) comb-type))
       comb-constraints
       (reduce (lambda (prev next) (append (make-constraints next decl) prev)) (list) args)))))

;;; Unification

(def-fun! unify (constraints)
  (def-fun! unify-h (stack substs)
    (if (empty? stack)
        substs
        (let* (next (car stack)
               left (constraint-left next)
               right (constraint-right next))
          (cond
            ((type-equal? left right) (unify-h (cdr stack) substs))
            ((type-var? left) (unify-h
                               (substitute-constraints left rigth (cdr stack) :subtype)
                               (cons next (substitute-constraints left right substs :subtype))))
            ((type-var? right) (unify-h
                                (substitute-constraints rigth left (cdr stack) :supertype)
                                (cons next (substitute-constraints right left substs :supertype))))
            ((and? (type? left)
                   (type? right))
             (unify-h
              (append (unify-types left right) (cdr stack))
              substs))
            (#t (print "Can't unify!")
                (print left)
                (print right)
                (list))))))
  (unify-h constraints (list)))

(def-fun! substitute-constraints (from to constraints relation)
  (map (lambda (constraint)
         (make-constraint
          (if (and? (eql? relation :subtype)
                    (eql? from (constraint-left constraint)))
              to
              (if (eql? relation :supertype)
                  (substitute-side from to (constraint-left constraint))
                  (constraint-left constraint)))
          (if (and? (eql? relation :supertype)
                    (eql? from (constraint-right constraint)))
              to
              (if (eql? relation :supertype)
                  (substitute-side from to (constraint-right constraint))
                  (constraint-right constraint)))))
       constraints))

(def-fun! substitute-side (from to side)
  (if (type? side)
      (substitute-type from to side)
      type))

(def-fun! substitute-type (from to type)
  (cond
    ((any? (lambda (pred) (pred type)) and-type? sum-type? prod-type?)
     ((type-constructor type)
      (map (curry substitute-type from to) (type-data-of type))))
    ((record-type? type)
     (substitute-record-type type))
    (#t type)))

(def-fun! unify-types (left right))

(def-fun! unify-types? (child parent)
  (cond
    ((enum-type? child)
     (enum-subset? child parent))
    ((pred-type? child)
     (pred-subset? child parent))
    ((and (and-type? child) (and-type? parent))
     (and-subset-and? child parent))
    ((and-type? child)
     (and-subset? child))
    (#t (print "Non-unifiable types!")
        (print child)
        (print parent)
        (list))))

;; Subsetting enums
;; (def-fun! enum-subset? (child parent)
;;   (map (lambda (variant)
;;          (make-constraint ())
;;          ))
;;   (all? (curry of-type? parent) (enum-type-variants child)))

;; Subsetting for preds
(def-fun! pred-subset? (child parent)) ; No idea yet

;; Subsetting for ands
(def-fun! and-subset-and? (child parent)
  (all?
   (lambda (type) (any? (rcurry is-subset? type) (and-type-types-of child)))
   (and-types-type-of parent))) ; So all parent predicates are subset of at least one child predicate

(def-fun! and-subset? (child parent)
  (any? (rcurry is-subset? parent) (and-type-types-of child))) ; So at least one predicate is a subset of a parent

;; Subsetting for sums
(def-fun! sum-subset? (child parent)
  (map (rcurry make-constraint parent) (sum-type-types-of child)))

;; (def-fun! make-constraints (form decl &rest declared-type)
;;   (let (actual-form (car form)
;;         tv (cdr form))
;;     (if (not (cons? actual-form))
;;         (make-atom-constraints actual-form decl tv)
;;         (if (not (cons? (car (car actual-form))))
;;             (let (comb (eval (car (car actual-form)) decl))
;;               (cond
;;                 ((eql? comb :the-type) (make-the-constraints actual-form decl tv))
;;                 ((eql? comb :def-in!-type) (make-definer-constraints actual-form decl tv))
;;                 ((eql? comb :set-in!-type) (make-setter-constraints actual-form decl tv))
;;                 ((any? (curry eql? comb) (list :prod-type :op-type :fun-type)) (make-type-combiner-constraints actual-form decl tv))
;;                 ((eql? comb :cons-type) (if declared-type
;;                                             (make-declared-pair-constraints actual-form decl tv (car declared-type))
;;                                             (make-pair-constraints actual-form decl tv)))
;;                 ((eql? comb :lambda-type) (if declared-type
;;                                               (make-declared-lambda-constraints actual-form decl tv (car declared-type))
;;                                               (make-lambda-constraints actual-form decl tv)))
;;                 (#t (make-combiner-constraints actual-form decl tv))))
;;             (make-combiner-constraints actual-form decl tv)))))

;; (def-fun! make-atom-constraints (atom decl tv)
;;   (list
;;    (make-constraint tv
;;                (cond
;;                  ((number? atom) number)
;;                  ((boolean? atom) bool)
;;                  (#t (eval atom decl))))))

;; (def-fun! make-the-constraints (form decl tv)
;;   (destructuring-bind (_ type value) form
;;     (let* (type-constraints (make-constraints type decl)
;;            value-constraints (make-constraints value decl (normalize type decl)))
;;       (append
;;        (list
;;         (make-constraint tv (cdr value)))
;;        type-constraints
;;        value-constraints))))

;; (def-fun! make-definer-constraints (form decl tv)
;;   (destructuring-bind (_ env var value) form
;;     (let (value-constraints (make-constraints value decl)
;;           definer-env (eval (car env) decl))
;;       (def-in! definer-env symbol (cdr value))
;;       (append
;;        (list
;;         (make-constraint (cdr env) definer-env)
;;         (make-constraint (cdr var) symbol)
;;         (make-constraint tv (cdr var)))
;;        value-constraints))))

;; (def-fun! make-setter-constraints (form decl tv)
;;   (destructuring-bind (_ env var value) form
;;     (let (value-constraints (make-constraints value decl)
;;           setter-env (eval (car env) decl)
;;           var-type (eval (car var) decl))
;;       (append
;;        (list
;;         (make-constraint (cdr env) setter-env)
;;         (make-constraint (cdr var) symbol)
;;         (make-constraint tv (cer value))
;;         (make-constraint (cdr var) var-type))
;;        value-constraints))))

;; (def-fun! make-declared-pair-constraints (form decl tv declared-type)
;;   (destructuring-bind (_ left right) form
;;     (append
;;      (list
;;       (make-constraint (cdr left) (tc-left declared-type))
;;       (make-constraint (cdr right) (if (eql? fun (tc-right declared-type))
;;                                         ((tc-right declared-type) (normalize left decl))
;;                                         (tc-right declared-type)))
;;       (make-constraint tv declared-type))
;;      (make-constraints left decl)
;;      (make-constraints right decl))))

;; (def-fun! make-declared-lambda-constraints (form decl tv declared-type))

;; (def-fun! make-pair-constraints (form decl tv)
;;   (destructuring-bind (_ left right) form
;;     (append
;;      (list
;;       (make-constraint tv (prod (cdr left) (cdr right))))
;;      (make-constraints left decl)
;;      (make-constraints right decl))))

;; (def-fun! make-lambda-constraints (form decl tv)
;;   (destructuring-bind (_ lambda-list &rest body) form
;;     (let* (lambda-decl (make-env decl))
;;       (map (lambda (p) (dyn-def-in! lambda-decl (car p) (cdr p))) (car lambda-list))
;;       (append
;;        (list
;;         (make-constraint tv (fun (apply prod-list (map cdr (car lambda-list))) (cdr (last body)))))
;;        (reduce (lambda (prev next) (append (make-constraints next lambda-decl) prev)) (list) body)))))

;; (def-fun! make-type-combiner-constraints (form decl tv)
;;   (destructuring-bind (_ left right) form
;;     (append
;;      (list
;;       (make-constraint tv type)
;;       (make-constraint (cdr left) type)
;;       (make-constraint (cdr right) type))
;;      (make-constraints left decl)
;;      (make-constraints right decl))))

;; (def-fun! make-combiner-constraints (form decl tv)
;;   (destructuring-bind (comb &rest args) form
;;     (let* (comb-constraints (make-constraints comb decl)
;;            comb-type (constraint-right (find-constraint (cdr comb) comb-constraints)))
;;       (append
;;        (list
;;         (make-constraint tv (tc-right comb-type))
;;         (make-constraint (cdr comb) comb-type)
;;         (make-constraint comb-type (fun (apply prod-list (map cdr args)) tv)))
;;        comb-constraints
;;        (reduce (lambda (prev next) (append (make-constraints next decl) prev)) (list) args)))))

;; ;; Unification

;; (def-fun! unify (constraints)
;;   (def-fun! unify-h (stack substs)
;;     (if (empty? stack)
;;         substs
;;         (let* (next (car stack)
;;                left (constraint-left next)
;;                right (constraint-right next))
;;           (cond
;;             ((type-equal? left right) (unify-h (cdr stack) substs))
;;             ((type-var? left) (unify-h
;;                                (substitute-constraints next (cdr stack))
;;                                (cons next (substitute-constraints next substs))))
;;             ((type-var? right) (unify-h
;;                                 (cons (make-constraint right left) (cdr stack))
;;                                 substs))
;;             ((and? (tc? left)
;;                    (tc? right))
;;              (unify-h
;;               (append (unify-tc left right) (cdr stack))
;;               substs))
;;             (#t (print "Can't unify!")
;;                 (print left)
;;                 (print right)
;;                 (list))))))
;;   (unify-h constraints (list)))

;; (def-fun! unify-tc (left right)
;;   (list
;;    (make-constraint (tc-left left) (tc-left right))
;;    (make-constraint (tc-right left) (tc-right right))))

;; (def-fun! substitute-constraints (subst constraints)
;;   (map (lambda (constraint)
;;          (make-constraint
;;           (substitute-side subst (constraint-left constraint))
;;           (substitute-side subst (constraint-right constraint))))
;;        constraints))

;; (def-fun! substitute-side (subst side)
;;   (cond
;;     ((eql? side (constraint-left subst)) (constraint-right subst))
;;     ((tc? side) ((tc-constructor-fun side)
;;                  (substitute-side subst (tc-left side))
;;                  (substitute-side subst (tc-right side))))
;;     (#t side)))

;; (def-op! check-op env (form type decl)
;;   (check form type (eval decl env)))

;; (def-fun! check (form type decl)
;;   (let (type (infer type decl))
;;     (if (not? (cons? form))
;;         (type-equal? type (infer form decl))
;;         (let (comb (eval (car form) decl))
;;           (cond
;;             ((eql? comb :cons-type) (check-pair form type decl))
;;             ((eql? comb :lambda-type) (check-lambda form type decl)) ;; Should be vau
;;             (#t (type-equal? type (infer form decl))))))))

;; (def-fun! check-type-constructor (left right type decl)
;;   (let (left-value (normalize left decl))
;;     (and?
;;      (check left-value (tc-left type) decl)
;;      (check right-value ((tc-rigth type) left-value) decl))))

;; (def-fun! check-pair (form type decl)
;;   (destructuring-bind (_ left right) form
;;     (check-type-constructor left right type decl)))

;; (def-fun! check-lambda (form type decl)
;;   (destructuring-bind (_ lambda-list body) form ;; TODO - &rest handling
;;     (check-type-constructor (car lambda-list) body))) ;; TODO - should handle multi-argument lambda-lists

;; (def-op! infer-op env (form decl)
;;   (infer form (eval decl env)))

;; (def-fun! infer (form decl)
;;   (if (not? (cons? form))
;;       (infer-atom form decl)
;;       (let (comb (eval (car form) decl))
;;        (cond
;;          ((eql? comb :declare-type) (infer-annotation form decl))
;;          ((some? (curry eql? comb) (list :prod-type :op-type :fun-type)) (infer-type-combiner form decl))
;;          ((eql? comb :cons-type) (infer-pair form decl))
;;          ((eql? comb :lambda-type ) (infer-lambda form decl))
;;          (#t (infer-comb form decl))))))

;; (def-fun! infer-atom (atom decl)
;;   (cond
;;     ((number? atom) number)
;;     ((boolean? atom) bool)
;;     (#t (eval atom decl))))

;; (def-fun! infer-annotation (form decl)
;;   (destructuring-bind (_ symbol value) form
;;     (if (check value type decl)
;;         (do
;;          (dyn-def-in! decl symbol (infer value decl))
;;          bool)
;;         #f)))

;; (def-fun! infer-type-combiner (form decl)
;;   (destructuring-bind (_ left right) form
;;     (if (and?
;;          (check left type decl)
;;          (or?
;;           (check right type decl)
;;           (check right (fun left type) decl)))
;;         type
;;         #f)))

;; (def-fun! infer-pair (form decl)
;;   (destructuring-bind (_ left right) form
;;     (prod (infer left decl) (infer right decl))))

;; (def-fun! infer-lambda (form decl)
;;   (destructuring-bind (_ lambda-list body) form ;; TODO - should handle &rest for body
;;     (let (lambda-decl (make-env decl)
;;           type-variables (make-type-variable-list (length lambda-list)))
;;       (map (lambda (p) (extend lambda-decl (car p) (cdr p)))
;;            (zip (lambda-list) type-variables))
;;       (fun (apply prod-list type-combiner) (infer body lambda-decl)))))

;; (def-fun! infer-comb (form decl)
;;   (destructuring-bind (comb arg) form ;; TODO should handle multi-argument functions and should handle vau
;;     (let (comb-type (infer comb decl)
;;                     arg-type (infer arg decl))
;;       (if (check (tc-left comb-type) arg-type decl)
;;           (tc-right comb-type)
;;           #f))))