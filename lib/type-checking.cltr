;;;; Inference

;;; Entry level

(def-op! infer-code env (code decl)
  (let (ast (print (mark-ast code)))
    (substitute-vars
     ast
     (unify-constraints (print (make-constraints ast (eval decl env)))))))

;;; AST marking

(def-struct! variable name)

(def-fun! mark-ast (ast)
  (let (counter 0)
    (letrec (mark-ast-helper
             (lambda (ast)
               (let (current counter)
                 (set! counter (+ counter 1))
                 (cons (if (cons? ast)
                           (map mark-ast-helper ast)
                           ast)
                       (make-variable current)))))
      (mark-ast-helper ast))))

(def-fun! substitute-vars (ast constraints)
  (letseq (form (car ast)
         var (cdr ast)
         subed-form (if (cons? form)
                        (map (rcurry substitute-vars constraints) form)
                        form))
    (let (subst (find-constraint var constraints))
      (if (false? subst)
          subed-form
          (cons subed-form (constraint-right subst))))))

;;; Constraints

(def-struct! constraint left right)

(def-fun! find-constraint (key list)
  (if (empty? list)
      #f
      (if (eql? key (constraint-left (car list)))
          (car list)
          (find-constraint key (cdr list)))))

;;; Constraint generation

(def-fun! make-constraints (form decl &rest declared-type)
  (let (actual-form (car form)
        tv (cdr form))
    (if (not (cons? actual-form))
        (make-atom-constraints actual-form decl tv)
        (if (not (cons? (car (car actual-form))))
            (let (comb (eval (car (car actual-form)) decl))
              (cond
                (#t (make-combiner-constraints actual-form decl tv))))
            (make-combiner-constraints actual-form decl tv)))))

(def-fun! make-atom-constraints (atom decl tv)
  (list
   (make-constraint tv
                    (if ((disjoin number? boolean? keyword?) atom)
                        (make-literal-type atom)
                        (eval atom decl)))))

(def-fun! make-combiner-constraints (form decl tv)
  (destructuring-bind (comb &rest args) form
    (letseq (comb-constraints (make-constraints comb decl)
             comb-type (constraint-right (find-constraint (cdr comb) comb-constraints)))
      (append
       (list
        (make-constraint (make-product-type (map cdr args)) (arrow-type-from comb-type))
        (make-constraint tv (arrow-type-to comb-type)))
       comb-constraints
       (reduce (lambda (prev next) (append (make-constraints next decl) prev)) (list) args)))))

;;; Unification

;; Subsitution

;; x <: T, A <: B, (x\T)A <: A
;; ---------------------------
;;        (x\T)A <: B

;; x <: T, A <: B, B <: (x\T)B
;; ---------------------------
;;        A <: (x\T)B

;;   x <: T, A = x
;; ------------------
;;     A <: (x\T)A

;;   x <: T, A = x * B
;; -------------------
;;     A <: (x\T)A

;;   x <: T, A = x -> B
;; ---------------------
;;     (x\T)A <: A

;;   x <: T, A = B -> x
;; ---------------------
;;       A <: (x\T)A

;;   x <: T, A = x + B
;; ---------------------
;;     (x\T)A <: A

;;   x <: T, A = x & B
;; ---------------------
;;     A <: (x\T)A

(def-fun! substitute-constraints (from to constraints)
  (map (lambda (constraint)
         (make-constraint (substitute-type from to :subtype (constraint-left constraint))
                          (substitute-type from to :supertype (constraint-right constraint))))
       constraints))

(def-fun! complement-substitution-kind (kind)
  (if (eql? kind :supertype)
      :subtype
      :supertype))

(def-fun! substitute-type (from to kind type)
  (cond
    ((and? (eql? from type)
           (eql? kind :supertype))
     to)
    ((product-type? type)
     (make-product-type
      (map (curry substitute-type from to kind)
           (product-type-types type))))
    ((arrow-type? type)
     (make-arrow-type (substitute-type from to (complement-substitution-kind kind)
                                       (arrow-type-from type))
                      (substitute-type from to kind
                                       (arrow-type-to type))))
    ((record-type? type)
     (make-record-type (plist-map-values (curry substitute-type from to kind) (record-type-types type))))
    (#t type)))

;; Preprocessing merging

(def-fun! merge-to-intersections (constraints)
  (map merge-constraints
       (group-by (fork eql?
                       constraint-left
                       constraint-left)
                 (sort-by (fork type-order?
                                constraint-left
                                constraint-left)
                                  constraints))))

(def-fun! merge-constraints (constraints)
  (make-constraint (constraint-left (first constraints))
                   (normalize-group-type
                    (make-intersection-type (map constraint-right constraints)))))

;; Unification

(def-fun! unify-constraints (constraints)
  (def-fun! unify-h (stack substs)
    (print "Next step")
    (print stack)
    (print substs)
    (if (empty? stack)
        substs
        (letseq (next (car stack)
                 child (constraint-left next)
                 parent (constraint-right next))
          (cond
            ((eql? child parent) (unify-h (cdr stack) substs))
            ((variable? child)
             (let (subs (curry substitute-constraints child parent))
               (unify-h
                (merge-to-intersections (subs (cdr stack)))
                (merge-to-intersections (cons next (subs substs))))))
            ((or? (bottom? child)
                  (top? parent))
             (unify-h (cdr stack) substs))
            ((or? (group-type? child)
                  (group-type? parent))
             (find-by (complement false?)
                      (map (compose (rcurry unify-h substs)
                                    merge-to-intersections
                                    (curry append (cdr stack)))
                           (unify-group-types child parent))))
            ((and? (type? child)
                  (type? parent))
             (let (result (unify-types child parent))
               (when result
                 (unify-h (merge-to-intersections (append (cdr stack) result))
                          substs))))))))
  (unify-h (merge-to-intersections constraints) (list)))

(def-fun! unify-types (child parent)
  (cond
    ((and? (literal-type? child)
           (literal-type? parent))
     (unify-literals child parent))
    ((literal-type? child)
     (unify-literal-child child parent))
    ((and? (primitive-type? child)
           (primitive-type? parent))
     (unify-primitives child parent))
    ((and? (product-type? child)
           (product-type? parent))
     (unify-products child parent))
    ((and? (arrow-type? child)
           (arrow-type? parent))
     (unify-arrows child parent))
    ((and? (record-type? child)
           (record-type? parent))
     (unify-records child parent))))

(def-fun! unify-literals (child parent)
  ;; This is fail only unifier, equal literals just eliminate
  (list
   (make-constraint (literal-type-atom child)
                    (literal-type-atom parent))))

(def-fun! unify-literal-child (child parent)
  (cond
    ((primitive-type? parent) (make-constraint (atom-primitive-type (literal-type-atom child))
                                               parent))))

(def-fun! unify-primitives (child parent)
  ;; This is fail only unifier, equal primitives just eliminate
  (list
   (make-constraint (primitive-type-name child)
                    (primitive-type-name parent))))

(def-fun! unify-products (child parent)
  (let (child-types (product-type-types child)
        parent-types (product-type-types parent))
    (when (eql? (length child-types)
                (length parent-types))
      (map make-constraint
           child-types
           parent-types))))

(def-fun! unify-arrows (child parent)
  (list
   (make-constraint (arrow-type-from parent) (arrow-type-from child))
   (make-constraint (arrow-type-to child) (arrow-type-to parent))))

(def-fun! unify-records (child parent)
  (map (lambda (label)
         (make-constraint (record-type-get label child)
                          (record-type-get label parent)))
       (record-type-labels parent)))

(def-fun! unify-group-types (child parent)
  (cond
    ((sum-type? child)
     (unify-sum-child (normalize-group-type child) parent))
    ((sum-type? parent)
     (unify-sum-parent child (normalize-group-type parent)))
    ((intersection-type? child)
     (unify-intersection-child (normalize-group-type child) parent))
    ((intersection-type? parent)
     (unify-intersection-parent child (normalize-group-type parent)))))

(def-fun! unify-sum-child (child parent)
  (list (map (rcurry make-constraint parent) (sum-type-types child))))

(def-fun! unify-sum-parent (child parent)
  (map (compose list (curry make-constraint child))
       (sum-type-types parent)))

(def-fun! unify-intersection-child (child parent)
  (map (compose list (rcurry make-constraint parent))
       (intersection-type-types child)))

(def-fun! unify-intersection-parent (child parent)
  (list (map (curry make-constraint child) (intersection-type-types parent))))