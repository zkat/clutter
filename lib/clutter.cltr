(def-in! ((vau env () env)) get-current-env
  (wrap (vau env () env)))

(def-in! (get-current-env) global-env
  (get-current-env))

(def-in! global-env def!
  (vau env (var value)
    (eval (list def-in! env var value) env)))

(def-in! global-env set!
  (vau env (var value)
    (eval (list set-in! env var value) env)))

(def! def-op!
  (vau env (name env-var vau-list &rest body)
    (eval (list def! name (list name-vau! (list* vau env-var vau-list body) (symbol-name name))) env)))

(def-op! lambda env (vau-list &rest body)
  (wrap (eval (list* vau #ignore vau-list body) env)))

(def! name-lambda!
    (lambda (l name)
      (name-vau! (unwrap l) name)
      l))

(def-op! def-fun! env (name lambda-list &rest body)
  (eval (list def! name (list name-lambda! (list* lambda lambda-list body) (symbol-name name))) env))

(def-op! lookup env (var lookup-env)
  (eval var (eval lookup-env env)))

(def-fun! zip (&rest sequences)
  (if (eql? (list) (first sequences))
      (list)
      (list* (map first sequences) (apply zip (map rest sequences)))))

(def-fun! map (function values)
  (if (eql? (list) values)
      (list)
      (cons (function (car values)) (map function (cdr values)))))

(def-op! do env (&rest body)
  (let (last-value ())
    (map (lambda (exp) (set! last-value (eval exp env)))
         body)
    last-value))

(def-op! cond env (&rest forms)
  (if (eql? forms ())
      #f
      (if (eval (car (car forms)) env)
          (eval (list* do (cdr (car forms)))
                env)
          (eval (list* cond (cdr forms)) env))))

(def-fun! assoc (key alist)
  (if (eql? alist (list))
      #f
      (if (eql? key (car (car alist)))
          (car alist)
          (assoc key (cdr alist)))))

(def-fun! not? (value)
  (if value
      #f
      #t))
(def-fun! null? (value)
  (if (eql? value (list)) #t #f))

(def-fun! complement (function)
  (lambda (&rest args)
    (not? (apply function args))))

(def-fun! empty? (sequence)
  (=? (length sequence) 0))

(def-fun! filter (predicate sequence)
  (if (empty? sequence)
      (list)
      (if (predicate (first sequence))
          (cons (first sequence) (filter predicate (rest sequence)))
          (filter predicate (rest sequence)))))

(def-fun! even? (number)
  (=? (rem number 2) 0))

(def-fun! odd? (number)
  (not? (even? number)))

(def-op! inc! env (var)
  (eval (list set! var (+ 1 (eval var env))) env))

(def-op! let env (clauses &rest body)
  (eval (list*
         (list* lambda
                (filter ((lambda (x) (lambda (#ignore) (odd? (inc! x)))) 0)
                        clauses)
                body)
         (filter ((lambda (x) (lambda (#ignore) (even? (inc! x)))) 0)
                 clauses))
        env))

(def-op! when env (test &rest body)
  (if (eval test env)
      (eval (list* do body) env)
      #f))

(def-op! unless env (test &rest body)
  (if (eval test env)
      #f
      (eval (list* do body) env)))

(def-op! returning env (first &rest body)
  (let (return-val (eval first env))
    (map (curry eval env) body)
    return-val))

(def-op! push! env (value place)
  (eval (list set! place (list cons value place))
        env))

(def-fun! curry (function &rest first-args)
  (lambda (&rest last-args)
    (apply function (append first-args last-args))))

(def-fun! rcurry (function &rest last-args)
  (lambda (&rest first-args)
    (apply function (append first-args last-args))))

(def-fun! first (sequence)
  (car sequence))

(def-fun! second (sequence)
  (car (cdr sequence)))

(def-fun! rest (sequence)
  (cdr sequence))

(def-op! or? env (&rest values)
  (if (=? (length values) 0)
      #f
      (let (result (eval (first values) env))
        (if result
            result
            (eval (list* or? (rest values)) env)))))

(def-op! and? env (&rest values)
  (if (=? (length values) 0)
      #t
      (let (result (eval (first values) env))
        (if result
            (eval (list* and? (rest values)) env)
            #f))))

(def-fun! every? (predicate sequence)
  (if (eql? sequence (list))
      #t
      (and? (predicate (first sequence))
            (every? predicate (rest sequence)))))

(def-fun! some? (predicate sequence)
  (if (eql? sequence (list))
      #f
      (or? (predicate (first sequence))
           (some? predicate (rest sequence)))))

(def-fun! sequence? (object)
  (list? object))

(def-fun! combiner? (object)
  (or? (function? object)
       (operator? object)))

(def-fun! member? (item sequence)
  (if (>? (length sequence) 0)
      (if (eql? item (first sequence))
          #t
          (member? item (rest sequence)))
      #f))

(def-fun! apply (function args)
  (eval (cons (unwrap function) args) (get-current-env)))

(def-op! with-env callsite-env (target-env &rest body)
  (eval (list* do body) (eval target-env callsite-env)))

(def-op! module dyn-env (parent-envs &rest body)
  (let (env (apply make-env (map (rcurry eval dyn-env) parent-envs)))
    (map (rcurry eval env) body)
    env))

(def-op! provide! dyn-env (bindings parent-envs &rest body)
  (let (module-env (eval (list* module parent-envs body) dyn-env))
    (map (lambda (binding)
           (eval (list def-in! dyn-env binding (eval binding module-env)) dyn-env))
         bindings))
  bindings)

(def-op! providing-module dyn-env (bindings parent-envs &rest body)
  (eval (list module (list)
              (list* provide! bindings (map (curry eval dyn-env) parent-envs)
                     body))
        dyn-env))

(def-op! import-from! dyn-env (from-env &rest bindings)
  (let (env (eval from-env dyn-env))
    (map (lambda (binding)
           (eval (list def-in! dyn-env binding (eval binding env)) dyn-env))
         bindings))
  bindings)

(def! anaphora
  (module (global-env)

    (def-op! anaphoric env (op var test &rest body)
      (eval (list let (list var (eval test env))
                  (list* op var body))
            env))

    (def-op! aif env (var test then else)
      (eval (list anaphoric if var test then else) env))

    (def-op! awhen env (var test &rest body)
      (eval (list* anaphoric when var test body) env))

    (def-op! aunless env (var test &rest body)
      (eval (list* anaphoric unless var test body) env))

    (def-op! areturning env (var first &rest body)
      (eval (list* anaphoric returning var first body) env))

    ))
