(def-in! ((vau env () env)) get-current-env
  (wrap (vau env () env)))

(def-in! (get-current-env) global-env
  (get-current-env))

(def-in! global-env def!
  (vau env (var value)
    (eval (list def-in! env var value) env)))

(def-in! global-env set!
  (vau env (var value)
    (eval (list set-in! env var value) env)))

(def! def-op!
 (vau env (name env-var vau-list &rest body)
   (eval (list def! name
               (list name-vau! (list* vau env-var vau-list body) name))
         env)))

(def-op! dyn-def-in! dyn-env (env var value)
  (eval (list def-in!
              (list (unwrap eval) env dyn-env)
              (eval var dyn-env)
              (list (unwrap eval) value dyn-env))
        dyn-env))

(def-op! dyn-set-in! dyn-env (env var value)
    (eval (list set-in!
                (list (unwrap eval) env dyn-env)
                (eval var dyn-env)
                (list (unwrap eval) value dyn-env))
          dyn-env))

(def-op! lambda env (vau-list &rest body)
  (wrap (eval (list* vau #ignore vau-list body) env)))

(def-op! name-lambda! env (l name)
  ((lambda (obj)
     (eval (list name-vau! (list unwrap obj) name) env)
     obj)
   (eval l env)))

(def! fun-name
  (lambda (f)
    (vau-name (unwrap f))))

(def-op! def-fun! env (name lambda-list &rest body)
  (eval (list def! name
              (list name-lambda!(list* lambda lambda-list body) name))
        env))

(def-op! lookup env (var lookup-env)
  (eval var (eval lookup-env env)))

(def-fun! map1 (function values)
  (if (eql? (list) values)
      (list)
      (cons (function (car values)) (map function (cdr values)))))

(def-fun! zip (&rest sequences)
  (if (eql? (list) (first sequences))
      (list)
      (list* (map1 first sequences) (apply zip (map1 rest sequences)))))

(def-fun! map (function &rest lists)
  (map1 (curry apply function) (apply zip lists)))

(def-fun! reduce (function initial values)
  (if (eql? (list) values)
      initial
      (function initial (reduce function (car values) (cdr values)))))

(def-fun! flatten (sequence)
  (reduce append (list) sequence))

(def-op! destructuring-bind dyn-env (vau-list values &rest body)
  (let (env (make-env dyn-env))
    (def-fun! perform-binding (vau-list values)
      (cond
        ((empty? vau-list) #t)
        ((eql? (first vau-list) ((vau #ignore (x) x) &rest))
         (dyn-def-in! env (second vau-list) values))
        (#t
         (dyn-def-in! env (first vau-list) (first values))
         (perform-binding (rest vau-list) (rest values)))))

    (perform-binding vau-list (eval values dyn-env))
    (eval (cons do body) env)))

(def-op! do env (&rest body)
  (let (last-value #f)
    (map (lambda (exp) (set! last-value (eval exp env)))
         body)
    last-value))

(def-op! cond env (&rest forms)
  (if (empty? forms)
      #f
      (if (eval (car (car forms)) env)
          (eval (list* do (cdr (car forms))) env)
          (eval (list* cond (cdr forms)) env))))

(def-fun! assoc (key alist)
  (if (eql? alist (list))
      #f
      (if (eql? key (car (car alist)))
          (car alist)
          (assoc key (cdr alist)))))

(def-fun! not (value)
  (if value #f #t))
(def! false? not)

(def-fun! null? (value)
  (if (eql? value (list)) #t #f))

(def-fun! compose (function &rest more-functions)
  (reduce (lambda (f g)
            (lambda (&rest args)
              (f (apply g args))))
          function
          more-functions))

(def-fun! complement (function)
  (compose not function))

(def-fun! empty? (sequence)
  (null? sequence))

(def-fun! filter (predicate sequence)
  (if (empty? sequence)
      (list)
      (if (predicate (first sequence))
          (cons (first sequence) (filter predicate (rest sequence)))
          (filter predicate (rest sequence)))))

(def-fun! even? (number)
  (=? (rem number 2) 0))

(def! odd? (complement even?))

(def-op! inc! env (var)
  (eval (list set! var (list + 1 var)) env))

(def-op! let env (clauses &rest body)
  (eval (list*
         (list* lambda
                (filter ((lambda (x) (lambda (#ignore) (odd? (inc! x)))) 0)
                        clauses)
                body)
         (filter ((lambda (x) (lambda (#ignore) (even? (inc! x)))) 0)
                 clauses))
        env))

(def-op! letseq dyn-env (bindings &rest body)
  (let (env (make-env dyn-env))
    (if (null? bindings)
        (eval (cons do body) env)
        (do
         (dyn-def-in! env (car bindings) (eval (car (cdr bindings)) dyn-env))
         (eval (list* letseq (cdr (cdr bindings)) body) env)))))

(def-op! letrec dyn-env (bindings &rest body)
  (letseq (vars (filter (let (x 0) (lambda (#ignore) (odd? (inc! x)))) bindings)
           values (filter (let (x 0) (lambda (#ignore) (even? (inc! x)))) bindings)
           def-forms (cons do (map (lambda (var val) (list def! var val)) vars values)))
    (eval (list* let ()
                 def-forms
                 body)
          dyn-env)))

(def-op! letrecseq dyn-env (bindings &rest body)
  (eval (if (null? bindings)
            (list* letrec bindings body)
            (list letrec
                  (list (car bindings) (car (cdr bindings)))
                  (list* letrecseq (cdr (cdr bindings)) body)))
        dyn-env))

(def-op! when env (test &rest body)
  (if (eval test env)
      (eval (list* do body) env)
      #f))

(def-op! unless env (test &rest body)
  (if (eval test env)
      #f
      (eval (list* do body) env)))

(def-op! returning env (first &rest body)
  (let (return-val (eval first env))
    (map (rcurry eval env) body)
    return-val))

(def-op! push! env (value place)
  (eval (list set! place (list cons value place))
        env))

(def-fun! curry (function &rest first-args)
  (lambda (&rest last-args)
    (apply function (append first-args last-args))))

(def-fun! rcurry (function &rest last-args)
  (lambda (&rest first-args)
    (apply function (append first-args last-args))))

(def-fun! first (sequence)
  (car sequence))

(def-fun! second (sequence)
  (car (cdr sequence)))

(def-fun! rest (sequence)
  (cdr sequence))

(def-op! or? env (&rest expressions)
  (if (=? (length expressions) 0)
      #f
      (let (result (eval (first expressions) env))
        (if result
            result
            (eval (list* or? (rest expressions)) env)))))

(def-op! and? env (&rest expressions)
  (if (=? (length expressions) 0)
      #t
      (let (result (eval (first expressions) env))
        (if result
            (eval (list* and? (rest expressions)) env)
            #f))))

(def-fun! all? (predicate sequence)
  (apply (wrap and?) (map predicate sequence)))

(def-fun! any? (predicate sequence)
  (apply (wrap or?) (map predicate sequence)))

(def-fun! sequence? (object)
  (list? object))

(def-fun! combiner? (object)
  (or? (function? object)
       (operative? object)))

(def-fun! member? (item sequence)
  (if (>? (length sequence) 0)
      (if (eql? item (first sequence))
          #t
          (member? item (rest sequence)))
      #f))

(def-fun! replace-tree (tree old-value new-value)
  (if (and? (sequence? tree) (sequence? (rest tree)))
      (if (empty? tree)
          (list)
          (map (rcurry replace-tree old-value new-value) tree))
      (if (eql? tree old-value) new-value tree)))

(def-fun! apply (function args)
  (eval (cons (unwrap function) args) (get-current-env)))

(def-op! with-env callsite-env (target-env &rest body)
  (eval (list* do body) (eval target-env callsite-env)))

(def-op! module dyn-env (parent-envs &rest body)
  (let (env (apply make-env (map (rcurry eval dyn-env) parent-envs)))
    (map (rcurry eval env) body)
    env))

(def-op! provide! dyn-env (bindings parent-envs &rest body)
  (let (module-env (eval (list* module parent-envs body) dyn-env))
    (map (lambda (binding)
           (eval (list def-in! dyn-env binding (eval binding module-env)) dyn-env))
         bindings))
  bindings)

(def-op! providing-module dyn-env (bindings parent-envs &rest body)
  (eval (list module (list)
              (list* provide! bindings (map (curry eval dyn-env) parent-envs)
                     body))
        dyn-env))

(def-op! import-from! dyn-env (from-env &rest bindings)
  (let (env (eval from-env dyn-env))
    (map (lambda (binding)
           (let (var (if (list? binding) (car binding) binding)
                 val (list (unwrap eval) (if (list? binding) (car (cdr binding)) binding) env))
             (eval (list def-in! dyn-env var val) dyn-env)))
         bindings))
  bindings)

(def! anaphora
    (module (global-env)

            (def-op! anaphoric env (op var test &rest body)
              (eval (list let (list var (eval test env))
                          (list* op var body))
                    env))

            (def-op! aif env (var test then else)
              (eval (list anaphoric if var test then else) env))

            (def-op! awhen env (var test &rest body)
              (eval (list* anaphoric when var test body) env))

            (def-op! aunless env (var test &rest body)
              (eval (list* anaphoric unless var test body) env))

            (def-op! areturning env (var first &rest body)
              (eval (list* anaphoric returning var first body) env))

            ))
