(def-in! ((vau env () env)) get-current-env
  (wrap (vau env () env)))

(def-in! (get-current-env) global-env
  (get-current-env))

(def-in! global-env def!
  (vau env (var value)
       (eval (list def-in! env var value) env)))

(def-in! global-env set!
  (vau env (var value)
       (eval (list set-in! env var value) env)))

(def! def-op!
    (vau env (name env-var vau-list &rest body)
         (eval (list def! name (list name-vau! (list* vau env-var vau-list body) name)) env)))

(def-op! dyn-def-in! dyn-env (env var value)
  (eval (list def-in!
              (list (unwrap eval) env dyn-env)
              (eval var dyn-env)
              (list (unwrap eval) value dyn-env))
        dyn-env))

(def-op! dyn-set-in! dyn-env (env var value)
    (eval (list set-in!
                (list (unwrap eval) env dyn-env)
                (eval var dyn-env)
                (list (unwrap eval) value dyn-env))
          dyn-env))

(def-op! lambda env (vau-list &rest body)
  (wrap (eval (list* vau #ignore vau-list body) env)))

(def-op! name-lambda! env (l name)
  ((lambda (obj)
     (eval (list name-vau! (list unwrap obj) name) env)
     obj)
   (eval l env)))

(def! fun-name
    (lambda (f)
      (vau-name (unwrap f))))

(def-op! def-fun! env (name lambda-list &rest body)
  (eval (list def! name (list name-lambda! (list* lambda lambda-list body) name)) env))

(def-op! lookup env (var lookup-env)
  (eval var (eval lookup-env env)))

(def-fun! map1 (function values)
  (if (eql? (list) values)
      (list)
      (cons (function (car values)) (map function (cdr values)))))

(def-fun! zip (&rest sequences)
  (if (eql? (list) (first sequences))
      (list)
      (list* (map1 first sequences) (apply zip (map1 rest sequences)))))

(def-fun! map (function &rest lists)
  (map1 (curry apply function) (apply zip lists)))

(def-fun! reduce (function initial values)
  (if (eql? (list) values)
      initial
      (reduce function (function initial (car values)) (cdr values))))

(def-fun! flatten (sequence)
  (reduce append (list) sequence))

(def-op! destructuring-bind dyn-env (vau-list values &rest body)
  (let (env (make-env dyn-env))
    (def-fun! perform-binding (vau-list values)
      (cond
        ((empty? vau-list) #t)
        ((eql? (first vau-list) ((vau #ignore (x) x) &rest))
         (dyn-def-in! env (second vau-list) values))
        (#t
         (dyn-def-in! env (first vau-list) (first values))
         (perform-binding (rest vau-list) (rest values)))))

    (perform-binding vau-list (eval values dyn-env))
    (eval (cons do body) env)))

(def-op! do env (&rest body)
  (let (last-value #f)
    (map (lambda (exp) (set! last-value (eval exp env)))
         body)
    last-value))

(def-op! cond env (&rest forms)
  (if (empty? forms)
      #f
      (if (eval (car (car forms)) env)
          (eval (list* do (cdr (car forms))) env)
          (eval (list* cond (cdr forms)) env))))

(def-fun! not (value)
  (if value #f #t))
(def! false? not)

(def-fun! null? (value)
  (if (eql? value (list)) #t #f))

(def-fun! complement (function)
  (lambda (&rest args)
    (not (apply function args))))

(def-fun! empty? (sequence)
  (null? sequence))

(def! not-false? (complement false?))

(def! not-empty? (complement empty?))

(def-fun! filter (predicate sequence)
  (if (empty? sequence)
      (list)
      (if (predicate (first sequence))
          (cons (first sequence) (filter predicate (rest sequence)))
          (filter predicate (rest sequence)))))

(def-fun! even? (number)
  (=? (rem number 2) 0))

(def-fun! odd? (number)
  (not (even? number)))

(def-op! inc! env (var)
  (eval (list set! var (list + 1 var)) env))

(def-op! let env (clauses &rest body)
  (eval (list*
         (list* lambda
                (filter ((lambda (x) (lambda (#ignore) (odd? (inc! x)))) 0)
                        clauses)
                body)
         (filter ((lambda (x) (lambda (#ignore) (even? (inc! x)))) 0)
                 clauses))
        env))

(def-op! let* dyn-env (bindings &rest body)
  (let (env (make-env dyn-env))
    (if (null? bindings)
        (eval (cons do body) env)
        (do
         (dyn-def-in! env (car bindings) (eval (car (cdr bindings)) dyn-env))
         (eval (list* let* (cdr (cdr bindings)) body) env)))))

(def-op! letrec dyn-env (bindings &rest body)
  (let* (vars (filter (let (x 0) (lambda (#ignore) (odd? (inc! x)))) bindings)
         values (filter (let (x 0) (lambda (#ignore) (even? (inc! x)))) bindings)
         def-forms (cons do (map (lambda (var val) (list def! var val)) vars values)))
    (eval (list* let ()
                 def-forms
                 body)
          dyn-env)))

(def-op! letrec* dyn-env (bindings &rest body)
  (eval (if (null? bindings)
            (list* letrec bindings body)
            (list letrec
                  (list (car bindings) (car (cdr bindings)))
                  (list* letrec* (cdr (cdr bindings)) body)))
        dyn-env))

(def-op! when env (test &rest body)
  (if (eval test env)
      (eval (list* do body) env)
      #f))

(def-op! unless env (test &rest body)
  (if (eval test env)
      #f
      (eval (list* do body) env)))

(def-op! returning env (first &rest body)
  (let (return-val (eval first env))
    (map (rcurry eval env) body)
    return-val))

(def-op! push! env (value place)
  (eval (list set! place (list cons value place))
        env))

(def-fun! apply (function args)
  (eval (cons (unwrap function) args) (get-current-env)))

(def-fun! curry (function &rest first-args)
  (lambda (&rest last-args)
    (apply function (append first-args last-args))))

(def-fun! rcurry (function &rest last-args)
  (lambda (&rest first-args)
    (apply function (append first-args last-args))))

(def-fun! assoc-by (test key alist)
  (if (eql? alist (list))
      #f
      (if (test key (car alist))
          (car alist)
          (assoc-by test key (cdr alist)))))

(def! assoc (curry assoc-by
                   (lambda (key pair)
                     (eql? key (car pair)))))

(def-fun! nth (n sequence)
  (if (=? n 0)
      (car sequence)
      (nth (- n 1) (cdr sequence))))

(def-fun! first (sequence)
  (car sequence))

(def-fun! second (sequence)
  (nth 1 sequence))

(def-fun! third (sequence)
  (nth 2 sequence))

(def-fun! fourth (sequence)
  (nth 3 sequence))

(def-fun! fifth (sequence)
  (nth 4 sequence))

(def-fun! rest (sequence)
  (cdr sequence))

(def-fun! last (sequence)
  (if (eql? (list) (cdr sequence))
      (car sequence)
      (last (cdr sequence))))

(def-op! or? env (&rest expressions)
  (if (=? (length expressions) 0)
      #f
      (let (result (eval (first expressions) env))
        (if result
            result
            (eval (list* or? (rest expressions)) env)))))

(def-op! and? env (&rest expressions)
  (if (=? (length expressions) 0)
      #t
      (let (result (eval (first expressions) env))
        (if result
            (eval (list* and? (rest expressions)) env)
            #f))))

(def-fun! all? (predicate sequence)
  (apply (wrap and?) (map predicate sequence)))

(def-fun! any? (predicate sequence)
  (apply (wrap or?) (map predicate sequence)))

(def-fun! conjoin (predicate &rest more-predicates)
  (if (empty? more-predicates)
      predicate
      (letrec (helper
               (lambda (predicates value)
                 (if (empty? predicates)
                     #t
                     (and? ((car predicates) value)
                           (helper (cdr predicates) value)))))
        (curry helper (cons predicate more-predicates)))))

(def-fun! disjoin (predicate &rest more-predicates)
  (if (empty? more-predicates)
      predicate
      (letrec (helper
               (lambda (predicates value)
                 (if (empty? predicates)
                     #f
                     (or? ((car predicates) value)
                          (helper (cdr predicates) value)))))
        (curry helper (cons predicate more-predicates)))))

(def! atom? (disjoin boolean? symbol? keyword? number? string?))

(def-fun! compose (function &rest more-functions)
  (reduce (lambda (f g)
            (lambda (&rest args)
              (f (apply g args))))
          function
          more-functions))

(def-fun! sequence? (object)
  (list? object))

(def-fun! combiner? (object)
  (or? (function? object)
       (operative? object)))

(def-fun! member? (item sequence)
  (if (>? (length sequence) 0)
      (if (eql? item (first sequence))
          #t
          (member? item (rest sequence)))
      #f))

(def-fun! replace-tree (tree old-value new-value)
  (if (and? (sequence? tree) (sequence? (rest tree)))
      (if (empty? tree)
          (list)
          (map (rcurry replace-tree old-value new-value) tree))
      (if (eql? tree old-value) new-value tree)))

(def-op! with-env callsite-env (target-env &rest body)
  (eval (list* do body) (eval target-env callsite-env)))

(def-op! module dyn-env (parent-envs &rest body)
  (let (env (apply make-env (map (rcurry eval dyn-env) parent-envs)))
    (map (rcurry eval env) body)
    env))

(def-op! provide! dyn-env (bindings parent-envs &rest body)
  (let (module-env (eval (list* module parent-envs body) dyn-env))
    (map (lambda (binding)
           (eval (list def-in! dyn-env binding (eval binding module-env)) dyn-env))
         bindings))
  bindings)

(def-op! providing-module dyn-env (bindings parent-envs &rest body)
  (eval (list module (list)
              (list* provide! bindings (map (curry eval dyn-env) parent-envs)
                     body))
        dyn-env))

(def-op! import-from! dyn-env (from-env &rest bindings)
  (let (env (eval from-env dyn-env))
    (map (lambda (binding)
           (let (var (if (list? binding) (car binding) binding)
                 val (list (unwrap eval) (if (list? binding) (car (cdr binding)) binding) env))
             (eval (list def-in! dyn-env var val) dyn-env)))
         bindings))
  bindings)

(def! anaphora
    (module (global-env)

            (def-op! anaphoric env (op var test &rest body)
              (eval (list let (list var (eval test env))
                          (list* op var body))
                    env))

            (def-op! aif env (var test then else)
              (eval (list anaphoric if var test then else) env))

            (def-op! awhen env (var test &rest body)
              (eval (list* anaphoric when var test body) env))

            (def-op! aunless env (var test &rest body)
              (eval (list* anaphoric unless var test body) env))

            (def-op! areturning env (var first &rest body)
              (eval (list* anaphoric returning var first body) env))

            ))

(def-fun! init-gensym ()
  (let (counter 0)
    (letrec (generator
             (lambda (prefix)
               (inc! counter)
               (let (symbol (intern (make-string prefix counter)))
                 (if (bound? symbol)
                     (generator)
                     symbol))))
       generator)))

(def! gensym (init-gensym))

(def-op! def-struct! env (name &rest slot-names)
  (let* (str-name (symbol-name name)
         keyword (make-keyword str-name))
    (dyn-def-in! env
                 (intern (make-string "make-" str-name))
                 (curry list keyword))
    (dyn-def-in! env
                 (intern (make-string str-name "?"))
                 (conjoin list? (compose (curry eql? keyword) first)))
    (reduce (lambda (counter name)
              (dyn-def-in! env
                           (intern (make-string str-name "-" name))
                           (curry nth counter))
              (+ counter 1))
            1
            (map symbol-name slot-names))
    name))

(def-fun! replace-in-tree (alist tree)
  (let (assoc (assoc tree alist))
    (cond
      (assoc (cdr assoc))
      ((atom? tree) tree)
      (#t (cons (replace-in-tree alist (car tree))
                (replace-in-tree alist (cdr tree)))))))