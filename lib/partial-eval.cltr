;;; TODO: Structs here.
(def-fun! emit (code)
  (cons :dynamic code))
(def-fun! dynamic? (value)
  (and? (sequence? value)
        (eql? (car value) :dynamic)))
(def-fun! dynamic-code (dynamic)
  (cdr dynamic))

(def! static? (complement dynamic?))

(def! peval-prims (list))
(def-fun! peval-prim? (obj)
  (member? obj peval-prims))

(def! shadowed-prims (list))
(def-fun! shadowed-prim? (comb)
  (if (assoc comb shadowed-prims)
      #t
      #f))
(def-fun! shadowing-prim (obj)
  (cdr (assoc obj shadowed-prims)))

(def-op! def-peval-fun! env (shadowing name vau-list &rest body)
  (eval (list* def-fun! name vau-list body) env)
  (push! (eval name env) peval-prims)
  (push! (cons (eval shadowing env) (eval name env)) shadowed-prims))

(def-op! def-peval-op! env (shadowing name env-var vau-list &rest body)
  (eval (list* def-op! name env-var vau-list body) env)
  (push! (eval name env) peval-prims)
  (push! (cons (eval shadowing env) (eval name env)) shadowed-prims))

(def-peval-fun! + emit-+ (&rest values)
  (cond
    ((every? static? values) (apply + values))
    (#t (emit (list* + (map finalize values))))))

(def-peval-fun! - emit-- (&rest values)
  (cond
    ((every? static? values) (apply - values))
    (#t (emit (list* - (map finalize values))))))

(def-peval-fun! =? emit-=? (&rest values)
  (cond
    ((every? static? values) (apply =? values))
    (#t (emit (list* =? (map finalize values))))))

(def-peval-op! if emit-if denv (condition then else)
  (let (condition-val (smart-eval condition denv))
    (if (static? condition-val)
        (if condition-val
            (smart-eval then denv)
            (smart-eval else denv))
        (emit (list if (finalize condition-val)
                    (finalize (smart-eval then denv))
                    (finalize (smart-eval else denv)))))))

(def-peval-op! def-in! emit-def-in! denv (target-env name value)
  (print "DEF-IN!")
  (let (target-env-val (smart-eval target-env denv)
        value-val (smart-eval value denv))
    ;; TODO: Is this safe?  Might mess with interp state by side-effecting shared envs
    (when (static? target-env-val)
      (if (static? value-val)
          (dyn-def-in! target-env-val name value-val)
          (dyn-def-in! target-env-val name (emit name))))
    (emit (list def-in! (finalize target-env-val) name (finalize value-val)))))

(def-peval-op! set-in! emit-set-in! denv (target-env name value)
  (let (target-env-val (smart-eval target-env denv)
        value-val (smart-eval value denv))
    (print "SET-IN!")
    (print value-val)
    ;; TODO: Is this safe?  Might mess with interp state by side-effecting shared envs
    (when (static? target-env-val)
      (if (static? value-val)           ;TODO: Fix multiple evaluation of values
          (eval (list set-in! target-env-val name value-val) denv)
          (eval (list set-in! target-env-val name (emit name)) denv)))
    (emit (list set-in! (finalize target-env-val) name (finalize value-val)))))

(def-peval-fun! wrap emit-wrap (obj)
  (print "wrapping")
  (cond
    ((dynamic? obj) (emit (list wrap (finalize obj))))
    (#t (wrap obj))))

(def-fun! smart-eval-operator (form env)
  ;; TODO: Also inline functions being passed constant envs.
  (let (comb (smart-eval (first form) env))
    (if (operative? comb)
        (do
            (print "TESTING")
            (print comb)
         (if (print (or? (peval-prim? comb) (shadowed-prim? comb)))
             (eval (if (shadowed-prim? comb)
                       (list* (shadowing-prim comb) (rest form))
                       (list* comb (rest form)))
                   env)
             (if (primitive? comb)
                 (do (print "WARNING: Unsupported partial eval primitive!")
                     (print comb)
                   (emit form))
                 (inline (list* comb (rest form)) env))))
        (eval (list* (unwrap
                      (if (shadowed-prim? comb)
                          (shadowing-prim comb)
                          comb))
                     (map (rcurry smart-eval env) (rest form)))
              env))))

(def-fun! smart-eval (form env)
  (print "(")
  (print form)
  (let (result (cond
                 ((null? form) form)
                 ((list? form) (smart-eval-operator form env))
                 (#t (eval form env))))
    (print result)
    (print ")")
    result))

(def-fun! finalize (tree)
  (cond
    ((dynamic? tree) (dynamic-code tree))
    ((or? (list? tree) (symbol? tree)) (list quote tree))
    (#t tree)))

(def-peval-op! vau emit-vau static-env (env-var vau-list &rest body)
  (let (vau-env (make-env static-env))
    (map (lambda (binding)
           (dyn-def-in! vau-env binding (emit binding)))
         (cons env-var vau-list))
    (eval (list* vau env-var vau-list
                 (replace-tree
                  (map finalize
                       (map (rcurry smart-eval vau-env)
                            body))
                  vau-env (list get-current-env)))
          static-env)))

(def-peval-fun! eval emit-eval (expr env)
  (print "EVALLING")
  (def-fun! quote-dynamics (l)
    (cond
      ((not? (list? l)) l)
      ((empty? l) (list))
      ((eql? (first l) quote) l)
      ((dynamic? (first l)) (list* (list quote (first l))
                                   (quote-dynamics (rest l))))
      ((list? (first l)) (list* (quote-dynamics (first l)) (quote-dynamics (rest l))))
      (#t (list* (first l) (quote-dynamics (rest l))))))
  (cond
    ((static? env) (smart-eval (quote-dynamics expr) env))
    (#t (emit (list eval (finalize expr) (finalize env))))))

;;; Should be internal to peval to discourage external use.
(def-op! quote #ignore (x) x)

;;; Produce code that may be substituted for the supplied operator invocation.
(def-fun! inline (call-form outer-env)
  (print "inlining")
  (let (op (if (operative? (first call-form))
               (first call-form)
               (unwrap (first call-form))))
    (let (env (make-env (vau-env op)))
      (def-fun! perform-binding (vau-list values)
        (cond
          ((empty? vau-list) #t)
          ((eql? (first vau-list) ((vau #ignore (x) x) &rest))
           (dyn-def-in! env (second vau-list) values))
          (#t
           (dyn-def-in! env (first vau-list) (first values))
           (perform-binding (rest vau-list) (rest values)))))
      
      (perform-binding (cons (vau-denv-var op) (vau-args op)) (cons outer-env (rest call-form)))

      (let (results (map (rcurry smart-eval env)
                      (vau-body op)))
        (if (=? (length results) 1)
            (first results)
            (list* do results))))))

(def-fun! peval (form)
  (let (peval-env (make-env global-env))
    ;; primitives
    ;; TODO: automate
    (def-in! peval-env + emit-+)
    (def-in! peval-env - emit--)
    (def-in! peval-env =? emit-=?)
    (def-in! peval-env eval emit-eval)
    (def-in! peval-env vau emit-vau)
    (def-in! peval-env if emit-if)
    (def-in! peval-env def-in! emit-def-in!)
    (def-in! peval-env set-in! emit-set-in!)
    (def-in! peval-env wrap emit-wrap)

    (eval form peval-env)))

(def-op! pe #ignore (form)
  (peval form))
