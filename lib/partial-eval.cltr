;;; TODO: Structs here.
(def-fun! make-placeholder (x) (symbol-name x))
(def! placeholder? string?)
(def-fun! placeholder-symbol (x)
  (intern x))

(def-fun! emit (code)
  (cons :code code))
(def-fun! code? (value)
  (and? (sequence? value)
        (eql? (car value) :code)))
(def-fun! code-literal (code)
  (cdr code))
(def-fun! ensure-literal-code (val)
  (if (code? val)
      (code-literal val)
      val))

(def-fun! dynamic? (value)
  (or? (placeholder? value)
       (code? value)
       (and? (sequence? value)
             (some? dynamic? value))))

(def! static? (complement dynamic?))

(def! peval-prims (list))
(def-fun! peval-prim? (obj)
  (member? obj peval-prims))

(def! shadowed-prims (list))
(def-fun! shadowed-prim? (comb)
  (if (assoc comb shadowed-prims)
      #t
      #f))
(def-fun! shadowing-prim (obj)
  (cdr (assoc obj shadowed-prims)))

(def-op! def-peval-fun! env (shadowing name vau-list &rest body)
  (eval (list* def-fun! name vau-list body) env)
  (push! (eval name env) peval-prims)
  (push! (cons (eval shadowing env) (eval name env)) shadowed-prims))

(def-op! def-peval-op! env (shadowing name env-var vau-list &rest body)
  (eval (list* def-op! name env-var vau-list body) env)
  (push! (eval name env) peval-prims)
  (push! (cons (eval shadowing env) (eval name env)) shadowed-prims))

(def-peval-fun! + emit-+ (&rest values)
  (cond
    ((every? static? values) (apply + values))
    (#t (emit (list* + (map ensure-literal-code values))))))

(def-peval-fun! - emit-- (&rest values)
  (cond
    ((every? static? values) (apply - values))
    (#t (emit (list* - (map ensure-literal-code values))))))

(def-peval-op! def-in! emit-def-in! denv (target-env name value)
  (let (target-env-val (smart-eval target-env denv)
        value-val (smart-eval value denv))
    ;; TODO: Is this safe?  Might mess with interp state by side-effecting shared envs
    (when (static? target-env-val)
      (if (static? value-val)
          (dyn-def-in! target-env-val name value-val)
          (dyn-def-in! target-env-val name (make-placeholder name))))
    (emit (list def-in! target-env-val (make-placeholder name) value-val))))

(def-fun! smart-eval-operator (form env)
  ;; TODO: Also inline functions being passed constant envs.
  (let (op (eval (first form) env))
    (if (operative? op)
        (if (not? (or? (peval-prim? op) (shadowed-prim? op)))
            (if (primitive? op)
                (do (print "WARNING: Unsupported partial eval primitive!")
                    form)
                (inline (list* op (rest form)) env))
            (eval (if (shadowed-prim? op)
                      (list* (shadowing-prim op) (rest form))
                      form)
                  env))
        (if (or? (peval-prim? op) (shadowed-prim? op)
                 (and? (pure? op) (every? static? (rest form))))
            (eval (if (shadowed-prim? op)
                      (list* (shadowing-prim op) (rest form))
                      form)
                  env)
            (emit (list* op
                         (map (lambda (arg)
                                (if (static? arg)
                                    (smart-eval arg env)
                                    (emit arg)))
                              (rest form))))))))

(def-fun! smart-eval (form env)
  (cond
    ((list? form) (smart-eval-operator form env))
    (#t (eval form env))))

(def-fun! finalize (tree)
  (cond
    ((code? tree) (map finalize (code-literal tree)))
    ((placeholder? tree) (placeholder-symbol tree))
    ((or? (list? tree) (symbol? tree)) (list quote tree))
    (#t tree)))

(def-peval-op! vau emit-vau static-env (env-var vau-list &rest body)
  (let (vau-env (make-env static-env))
    (map (lambda (binding)
           (dyn-def-in! vau-env binding (make-placeholder binding)))
         (cons env-var vau-list))
    (eval (list* vau env-var vau-list
                 (map finalize
                      (map (rcurry smart-eval vau-env)
                           body)))
          static-env)))

;;; Should be internal to peval to discourage external use.
(def-op! quote #ignore (x) x)

;;; Produce code that may be substituted for the supplied operator invocation.
(def-fun! inline (call-form outer-env)
  (let (op (if (operative? (first call-form))
               (first call-form)
               (unwrap (first call-form))))
    (let (env (make-env (vau-env op)))
      (map (lambda (binding)
             (dyn-def-in! env (first binding) (second binding)))
           (if (operative? (first call-form))
               (list* (list (vau-denv-var op) outer-env)
                      (zip (vau-args op) (rest call-form)))
               (zip (vau-args op) (rest call-form))))
      (emit (cons do (map (rcurry smart-eval env) (vau-body op)))))))

(def-peval-op! eval emit-eval callsite-env (expr-code env-code)
  (let (expr (eval expr-code callsite-env)
        env  (eval env-code callsite-env))
    (cond
      ((static? env) (smart-eval expr env))
      (#t (emit (list eval expr-code env-code))))))

(def-fun! peval (form)
  (let (peval-env (make-env global-env))
    ;; primitives
    (def-in! peval-env + emit-+)
    (def-in! peval-env - emit--)
    (def-in! peval-env eval emit-eval)
    (def-in! peval-env vau emit-vau)

    (eval form peval-env)))

(def-op! pe #ignore (form)
  (peval form))
