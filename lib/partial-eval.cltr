;;; TODO: Structs here.
(def-fun! make-placeholder (x) (symbol-name x))
(def! placeholder? string?)
(def-fun! placeholder-symbol (x)
  (intern x))

(def-fun! dynamic? (value)
  (or? (placeholder? value)
       (and? (sequence? value)
             (some? dynamic? value))))

(def! static? (complement dynamic?))

(def! peval-prims (list))
(def-fun! peval-prim? (obj)
  (member? obj peval-prims))

(def-fun! emit-+ (&rest values)
  (cond
    ((every? static? values) (apply + values))
    (#t (list* + values))))
(push! emit-+ peval-prims)

(def-fun! emit-- (&rest values)
  (cond
    ((every? static? values) (apply - values))
    (#t (list* - values))))
(push! emit-+ peval-prims)

(def-fun! smart-eval-operator (form env)
  ;; TODO: Also inline functions being passed constant envs.
  (let (op (eval (first form) env))
    (if (operative? op)
        (if (not? (peval-prim? op))
            (if (primitive? op)
                (do (print "WARNING: Unsupported partial eval primitive!")
                    (eval form env))
                (inline (list* op (rest form)) env))
            (eval form env))
        (if (and? (pure? op) (every? static? (rest form)))
            (eval form env)
            (list* (unwrap op)
                   (map (lambda (arg)
                          (if (static? arg)
                              (smart-eval arg env)
                              arg))
                        (rest form)))))))

(def-fun! smart-eval (form env)
  (cond
    ((list? form) (smart-eval-operator form env))
    (#t (eval form env))))

(def-fun! unplaceholderify (tree)
  (if (sequence? tree)
      (map unplaceholderify tree)
      (if (placeholder? tree)
          (placeholder-symbol tree)
          tree)))

(def-op! emit-vau static-env (env-var vau-list &rest body)
  (let (vau-env (make-env static-env))
    (eval (list def! env-var (make-placeholder env-var)) vau-env)
    (map (lambda (binding)
           (eval (list def! binding (make-placeholder binding)) vau-env))
         vau-list)
    (eval (list* vau env-var vau-list
                 (unplaceholderify (map (rcurry smart-eval vau-env)
                                        body)))
          static-env)))
(push! emit-vau peval-prims)

;;; Produce code that may be substituted for the supplied operator invocation.
(def-fun! inline (call-form outer-env)
  (let (op (if (operative? (first call-form))
               (first call-form)
               (unwrap (first call-form))))
    (let (env (make-env (vau-env op)))
      (map (lambda (binding)
             (dyn-def-in! env (first binding) (second binding)))
           (if (operative? (first call-form))
               (list* (list (vau-denv-var op) outer-env)
                      (zip (vau-args op) (rest call-form)))
               (zip (vau-args op) (rest call-form))))
      (let (result (eval (list* do (vau-body op))
                     env))
        ;; Ensure that the result can be evaluated (FIXME: why do we need to quote here?)
        (cond
          ((list? result) (cons list result))
          ;; TODO: Symbols
          (#t result))))))

(def-op! emit-eval callsite-env (expr-code env-code)
  (let (expr (eval expr-code callsite-env)
        env  (eval env-code callsite-env))
    (cond
      ((not? (placeholder? env)) (smart-eval expr env))
      (#t (list eval expr-code env-code)))))
(push! emit-eval peval-prims)

(def-fun! peval (form)
  (let (peval-env (make-env global-env))
    (with-env peval-env
      (def! + emit-+)
      (def! - emit--)
      (def! eval emit-eval)
      (def! vau emit-vau))
    (eval form peval-env)))

(def-op! pe #ignore (form)
  (peval form))
